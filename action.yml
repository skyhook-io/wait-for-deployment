name: 'Skyhook Kubernetes Wait'
description: 'Wait for Kubernetes workloads to become ready. Delegates Rollout waits to skyhook-io/argo-rollouts-wait@v1.'
author: 'Skyhook'

branding:
  icon: 'clock'
  color: 'purple'

inputs:
  namespace:
    description: 'Default namespace for workloads that omit it'
    required: true
  workloads_json:
    description: 'JSON array from Inspect: [{kind,name,namespace?}]. May include kind=="Rollout".'
    required: true
  timeout:
    description: 'Wait timeout (e.g., 300s, 5m). Applied to all waits.'
    required: false
    default: '300s'
  show_status:
    description: 'After waiting, show kubectl status for the provided workloads'
    required: false
    default: 'true'
  verify_only:
    description: 'Pass-through to Argo Rollouts Wait when delegating (health check only)'
    required: false
    default: 'false'
  wait_for_deployment_id:
    description: 'Enable waiting for deployment-id annotation before rollout status (for async deploys like ArgoCD)'
    required: false
    default: 'false'
  expected_deployment_id:
    description: 'Wait until workload has this deployment-id annotation. Defaults to current GitHub run ID.'
    required: false
    default: ${{ github.run_id }}
  annotation_timeout:
    description: 'Timeout for waiting for deployment-id annotation (e.g., 300s, 5m).'
    required: false
    default: '300s'

runs:
  using: 'composite'
  steps:
    - name: Check required tools
      shell: bash
      run: |
        set -euo pipefail
        for b in kubectl jq; do
          command -v "$b" >/dev/null 2>&1 || { echo "::error::Missing $b"; exit 1; }
        done

    - name: Normalize inputs
      id: norm
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ inputs.namespace }}'
        JSON='${{ inputs.workloads_json }}'
        echo "$JSON" | jq empty || { echo "::error::workloads_json must be valid JSON array"; exit 1; }

        ROLLOUTS_JSON=$(echo "$JSON" | jq -c '[ .[] | select((.kind // "") == "Rollout") ]')
        NON_ROLLOUTS_JSON=$(echo "$JSON" | jq -c '[ .[] | select((.kind // "") != "Rollout") ]')
        COUNT=$(jq 'length' <<<"$ROLLOUTS_JSON")
        FIRST_NAME=$(jq -r '.[0].name // ""' <<<"$ROLLOUTS_JSON")
        FIRST_NS=$(jq -r '.[0].namespace // ""' <<<"$ROLLOUTS_JSON")

        echo "namespace=$NS"                        >> "$GITHUB_OUTPUT"
        echo "rollouts_json=$ROLLOUTS_JSON"         >> "$GITHUB_OUTPUT"
        echo "non_rollouts_json=$NON_ROLLOUTS_JSON"  >> "$GITHUB_OUTPUT"
        echo "rollouts_count=$COUNT"                >> "$GITHUB_OUTPUT"
        echo "first_rollout_name=$FIRST_NAME"       >> "$GITHUB_OUTPUT"
        echo "first_rollout_ns=$FIRST_NS"           >> "$GITHUB_OUTPUT"

        echo "üì¶ Parsed $(jq 'length' <<<"$NON_ROLLOUTS_JSON") standard workloads and $COUNT rollout(s)."

    - name: Validate single Rollout
      if: ${{ fromJSON(steps.norm.outputs.rollouts_count) > 1 }}
      shell: bash
      run: |
        echo "::error::Multiple Rollouts found. To avoid duplication, call skyhook-io/wait-for-rollout@v1 once per rollout (matrix or sequential)."
        echo "Rollouts detected:"
        echo '${{ steps.norm.outputs.rollouts_json }}' | jq -r '.[] | "  - \(.name) (ns: \(.namespace // "'${{ steps.norm.outputs.namespace }}'"))"'
        exit 1

    - name: Validate deployment-id inputs
      if: ${{ inputs.wait_for_deployment_id == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        EXPECTED_ID='${{ inputs.expected_deployment_id }}'
        if [ -z "$EXPECTED_ID" ]; then
          echo "::error::wait_for_deployment_id is true but expected_deployment_id is empty"
          exit 1
        fi
        echo "‚úì Will wait for deployment-id=$EXPECTED_ID"

    # Wait for deployment-id annotation on ALL workloads (for async deploys like ArgoCD)
    - name: Wait for deployment-id annotation
      if: ${{ inputs.wait_for_deployment_id == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        EXPECTED_ID='${{ inputs.expected_deployment_id }}'
        TIMEOUT='${{ inputs.annotation_timeout }}'
        ALL_JSON='${{ inputs.workloads_json }}'

        # Parse timeout to seconds
        if [[ "$TIMEOUT" =~ ^([0-9]+)s$ ]]; then
          TIMEOUT_SECS="${BASH_REMATCH[1]}"
        elif [[ "$TIMEOUT" =~ ^([0-9]+)m$ ]]; then
          TIMEOUT_SECS=$((${BASH_REMATCH[1]} * 60))
        else
          TIMEOUT_SECS=300
        fi

        echo "‚è≥ Waiting for deployment-id=$EXPECTED_ID on all workloads (timeout=${TIMEOUT_SECS}s)"

        # Get annotation using jq (more reliable than jsonpath for keys with hyphens)
        get_annotation() {
          local kind="$1" name="$2" ns="$3"
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')
          local json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null)

          case "$kind" in
            Deployment|StatefulSet|DaemonSet|Rollout)
              # Pod template annotation
              echo "$json" | jq -r '.spec.template.metadata.annotations["deployment-id"] // empty'
              ;;
            *)
              # Direct metadata annotation for other resources
              echo "$json" | jq -r '.metadata.annotations["deployment-id"] // empty'
              ;;
          esac
        }

        wait_for_annotation() {
          local kind="$1" name="$2" ns="$3"
          local start_time=$(date +%s)
          local current_id=""

          while true; do
            current_id=$(get_annotation "$kind" "$name" "$ns")

            if [ "$current_id" = "$EXPECTED_ID" ]; then
              echo "  ‚úì $kind/$name has deployment-id=$EXPECTED_ID"
              return 0
            fi

            elapsed=$(($(date +%s) - start_time))
            if [ $elapsed -ge $TIMEOUT_SECS ]; then
              echo "::error::Timeout waiting for $kind/$name to have deployment-id=$EXPECTED_ID (current: ${current_id:-<not set>})"
              exit 1
            fi

            echo "  ‚è≥ $kind/$name has deployment-id=${current_id:-<not set>}, waiting... (${elapsed}s elapsed)"
            sleep 5
          done
        }

        # Process all workloads from the JSON
        echo "$ALL_JSON" | jq -r '.[] | "\(.kind)\t\(.name)\t\(.namespace // "")"' | \
        while IFS=$'\t' read -r kind name ns; do
          [ -z "$kind" ] && continue
          resolved_ns="${ns:-$NS}"
          wait_for_annotation "$kind" "$name" "$resolved_ns"
        done

        echo "‚úÖ All workloads have deployment-id=$EXPECTED_ID"
        echo "‚è≥ Annotation wait complete. Proceeding to wait for rollout completion..."

    # Delegate exactly one Rollout to the Argo action
    # This step ALWAYS runs when there's a Rollout, regardless of wait_for_deployment_id
    # When wait_for_deployment_id is true, it runs AFTER the annotation wait completes
    - name: Wait for Argo Rollout
      if: ${{ fromJSON(steps.norm.outputs.rollouts_count) == 1 }}
      uses: skyhook-io/wait-for-rollout@v1
      with:
        rollout_name: ${{ steps.norm.outputs.first_rollout_name }}
        namespace: ${{ steps.norm.outputs.first_rollout_ns || steps.norm.outputs.namespace }}
        timeout: ${{ inputs.timeout }}
        verify_only: ${{ inputs.verify_only }}

    # Wait for standard k8s workloads
    # This step runs for all non-Rollout workloads
    # When wait_for_deployment_id is true, it runs AFTER the annotation wait completes
    - name: Wait for standard workloads
      if: ${{ fromJSON(steps.norm.outputs.non_rollouts_json).length > 0 }}
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        TIMEOUT='${{ inputs.timeout }}'
        JSON='${{ steps.norm.outputs.non_rollouts_json }}'

        extract() { echo "$JSON" | jq -r --arg K "$1" '.[] | select(.kind==$K) | [.name, (.namespace // "'$NS'")] | @tsv'; }

        echo "‚è≥ Waiting for standard workloads rollout to complete (timeout=$TIMEOUT)"

        # Helper function to wait for rollout to start
        # kubectl rollout status may return immediately if no rollout is in progress,
        # even if the Deployment spec was just updated. This function ensures we wait
        # for Kubernetes to actually start processing the rollout.
        wait_for_rollout_to_start() {
          local kind="$1" name="$2" ns="$3" max_wait=60
          local start_time=$(date +%s)
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')
          local initial_generation=0
          
          echo "    Checking if $kind/$name rollout has started..."
          
          # Get initial state to detect changes
          local initial_json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null || echo "{}")
          initial_generation=$(echo "$initial_json" | jq -r '.metadata.generation // 0')
          
          # First check: if rollout already finished or no change needed, return immediately
          local first_check_json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null || echo "{}")
          local first_gen=$(echo "$first_check_json" | jq -r '.metadata.generation // 0')
          local first_observed=$(echo "$first_check_json" | jq -r '.status.observedGeneration // 0')
          local first_ready=$(echo "$first_check_json" | jq -r '.status.readyReplicas // 0')
          local first_replicas=$(echo "$first_check_json" | jq -r '.spec.replicas // 0')
          local first_updated=$(echo "$first_check_json" | jq -r '.status.updatedReplicas // 0')
          
          # If rollout is already complete (observed == generation and all replicas ready)
          if [ "$first_observed" -eq "$first_gen" ] && [ "$first_ready" -eq "$first_replicas" ] && [ "$first_updated" -eq "$first_replicas" ]; then
            if [ "$first_gen" -gt "$initial_generation" ]; then
              echo "    ‚úì $kind/$name rollout already completed (generation=$first_gen, ready=$first_ready/$first_replicas)"
            else
              echo "    ‚úì $kind/$name no rollout needed (generation unchanged, ready=$first_ready/$first_replicas)"
            fi
            return 0
          fi
          
          # If no change detected and already stable, proceed quickly
          if [ "$first_gen" -eq "$initial_generation" ] && [ "$first_observed" -eq "$first_gen" ]; then
            echo "    ‚ö† $kind/$name no rollout detected (generation unchanged), proceeding to kubectl rollout status..."
            return 0
          fi
          
          # Otherwise, wait for rollout to start or complete
          while true; do
            local json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null || echo "{}")
            local generation=$(echo "$json" | jq -r '.metadata.generation // 0')
            local observed_gen=$(echo "$json" | jq -r '.status.observedGeneration // 0')
            local ready_replicas=$(echo "$json" | jq -r '.status.readyReplicas // 0')
            local replicas=$(echo "$json" | jq -r '.spec.replicas // 0')
            local updated_replicas=$(echo "$json" | jq -r '.status.updatedReplicas // 0')
            
            # Check if rollout is complete (observed == generation and all replicas match)
            if [ "$observed_gen" -eq "$generation" ] && [ "$ready_replicas" -eq "$replicas" ] && [ "$updated_replicas" -eq "$replicas" ]; then
              echo "    ‚úì $kind/$name rollout complete (generation=$generation, ready=$ready_replicas/$replicas)"
              return 0
            fi
            
            # Check if rollout is in progress
            if [ "$updated_replicas" -lt "$replicas" ] || [ "$ready_replicas" -lt "$replicas" ]; then
              echo "    ‚úì $kind/$name rollout in progress (updated=$updated_replicas/$replicas, ready=$ready_replicas/$replicas)"
              return 0
            fi
            
            # If observedGeneration < generation, Kubernetes hasn't processed the update yet
            if [ "$observed_gen" -lt "$generation" ]; then
              elapsed=$(($(date +%s) - start_time))
              echo "    ‚è≥ $kind/$name rollout pending (generation=$generation, observed=$observed_gen), waiting for controller... (${elapsed}s)"
            else
              elapsed=$(($(date +%s) - start_time))
              echo "    ‚è≥ $kind/$name status: gen=$generation, obs=$observed_gen, updated=$updated_replicas/$replicas, ready=$ready_replicas/$replicas (${elapsed}s)"
            fi
            
            elapsed=$(($(date +%s) - start_time))
            if [ $elapsed -ge $max_wait ]; then
              echo "    ‚ö† $kind/$name timeout after ${max_wait}s, proceeding to kubectl rollout status..."
              return 0
            fi
            
            sleep 2
          done
        }
 
        # Wait for Deployments
        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - Deployment/$name (ns: $ns)"
          # First, wait for rollout to start (if it hasn't already)
          wait_for_rollout_to_start "Deployment" "$name" "$ns"
          # Then wait for rollout to complete
          kubectl rollout status "deployment/$name" -n "$ns" --timeout "$TIMEOUT" || {
            echo "::error::Deployment/$name rollout failed or timed out"
            exit 1
          }
        done < <(extract "Deployment")

        # Wait for StatefulSets
        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - StatefulSet/$name (ns: $ns)"
          wait_for_rollout_to_start "StatefulSet" "$name" "$ns"
          kubectl rollout status "statefulset/$name" -n "$ns" --timeout "$TIMEOUT" || {
            echo "::warning::StatefulSet/$name rollout failed or timed out (non-blocking)"
          }
        done < <(extract "StatefulSet")

        # Wait for DaemonSets
        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - DaemonSet/$name (ns: $ns)"
          wait_for_rollout_to_start "DaemonSet" "$name" "$ns"
          kubectl rollout status "daemonset/$name" -n "$ns" --timeout "$TIMEOUT" || {
            echo "::warning::DaemonSet/$name rollout failed or timed out (non-blocking)"
          }
        done < <(extract "DaemonSet")

        echo "‚úÖ Standard workloads rollout completed."

    - name: Show status
      if: inputs.show_status == 'true'
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        ALL='${{ inputs.workloads_json }}'
        if [ -z "$ALL" ] || [ "$ALL" = "[]" ]; then
          echo "üìä No workloads provided for status."
          exit 0
        fi
        echo "üìä Final status for provided workloads:"
        echo "$ALL" | jq -r '.[] | "\(.kind)\t\(.name)\t\(.namespace // "")"' | \
        while IFS=$'\t' read -r kind name ns; do
          [ -z "$kind" ] && continue
          RES_NS="${ns:-$NS}"
          echo "‚Äî $kind/$name (ns: $RES_NS)"
          if [ "$kind" = "Rollout" ]; then
            # Only a summary; full details come from the delegated action
            kubectl argo rollouts get rollout "$name" -n "$RES_NS" --no-color || true
          else
            kubectl get "$kind" "$name" -n "$RES_NS" -o wide || true
          fi
        done