name: 'Skyhook Kubernetes Wait'
description: 'Wait for Kubernetes workloads to become ready. Delegates Rollout waits to skyhook-io/argo-rollouts-wait@v1.'
author: 'Skyhook'

branding:
  icon: 'clock'
  color: 'purple'

inputs:
  namespace:
    description: 'Default namespace for workloads that omit it'
    required: true
  workloads_json:
    description: 'JSON array from Inspect: [{kind,name,namespace?}]. May include kind=="Rollout".'
    required: true
  timeout:
    description: 'Wait timeout (e.g., 300s, 5m). Applied to all waits.'
    required: false
    default: '300s'
  show_status:
    description: 'After waiting, show kubectl status for the provided workloads'
    required: false
    default: 'true'
  verify_only:
    description: 'Pass-through to Argo Rollouts Wait when delegating (health check only)'
    required: false
    default: 'false'
  wait_for_deployment_id:
    description: 'Enable waiting for deployment-id annotation before rollout status (for async deploys like ArgoCD)'
    required: false
    default: 'false'
  expected_deployment_id:
    description: 'Wait until workload has this deployment-id annotation. Defaults to current GitHub run ID.'
    required: false
    default: ${{ github.run_id }}
  annotation_timeout:
    description: 'Timeout for waiting for deployment-id annotation (e.g., 300s, 5m).'
    required: false
    default: '300s'

runs:
  using: 'composite'
  steps:
    - name: Check required tools
      shell: bash
      run: |
        set -euo pipefail
        for b in kubectl jq; do
          command -v "$b" >/dev/null 2>&1 || { echo "::error::Missing $b"; exit 1; }
        done

    - name: Normalize inputs
      id: norm
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ inputs.namespace }}'
        JSON='${{ inputs.workloads_json }}'
        echo "$JSON" | jq empty || { echo "::error::workloads_json must be valid JSON array"; exit 1; }

        ROLLOUTS_JSON=$(echo "$JSON" | jq -c '[ .[] | select((.kind // "") == "Rollout") ]')
        NON_ROLLOUTS_JSON=$(echo "$JSON" | jq -c '[ .[] | select((.kind // "") != "Rollout") ]')
        COUNT=$(jq -r 'length' <<<"$ROLLOUTS_JSON" || echo "0")
        NON_ROLLOUTS_COUNT=$(jq -r 'length' <<<"$NON_ROLLOUTS_JSON" || echo "0")
        FIRST_NAME=$(jq -r '.[0].name // ""' <<<"$ROLLOUTS_JSON")
        FIRST_NS=$(jq -r '.[0].namespace // ""' <<<"$ROLLOUTS_JSON")

        echo "ROLLOUTS_JSON=$ROLLOUTS_JSON"
        echo "NON_ROLLOUTS_JSON=$NON_ROLLOUTS_JSON"
        echo "rollouts_count=$COUNT"
        echo "non_rollouts_count=$NON_ROLLOUTS_COUNT"
        echo "first_rollout_name=$FIRST_NAME"
        echo "first_rollout_ns=$FIRST_NS"

        echo "namespace=$NS"                        >> "$GITHUB_OUTPUT"
        echo "rollouts_json=$ROLLOUTS_JSON"         >> "$GITHUB_OUTPUT"
        echo "non_rollouts_json=$NON_ROLLOUTS_JSON"  >> "$GITHUB_OUTPUT"
        echo "rollouts_count=$COUNT"                >> "$GITHUB_OUTPUT"
        echo "non_rollouts_count=$NON_ROLLOUTS_COUNT" >> "$GITHUB_OUTPUT"
        echo "first_rollout_name=$FIRST_NAME"       >> "$GITHUB_OUTPUT"
        echo "first_rollout_ns=$FIRST_NS"           >> "$GITHUB_OUTPUT"

        echo "üì¶ Parsed $(jq 'length' <<<"$NON_ROLLOUTS_JSON") standard workloads and $COUNT rollout(s)."

    - name: Validate single Rollout
      if: ${{ fromJSON(steps.norm.outputs.rollouts_count) > 1 }}
      shell: bash
      run: |
        echo "::error::Multiple Rollouts found. To avoid duplication, call skyhook-io/wait-for-rollout@v1 once per rollout (matrix or sequential)."
        echo "Rollouts detected:"
        echo '${{ steps.norm.outputs.rollouts_json }}' | jq -r '.[] | "  - \(.name) (ns: \(.namespace // "'${{ steps.norm.outputs.namespace }}'"))"'
        exit 1

    - name: Validate deployment-id inputs
      if: ${{ inputs.wait_for_deployment_id == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        EXPECTED_ID='${{ inputs.expected_deployment_id }}'
        if [ -z "$EXPECTED_ID" ]; then
          echo "::error::wait_for_deployment_id is true but expected_deployment_id is empty"
          exit 1
        fi
        echo "‚úì Will wait for deployment-id=$EXPECTED_ID"

    # Wait for deployment-id annotation on ALL workloads (for async deploys like ArgoCD)
    - name: Wait for deployment-id annotation
      if: ${{ inputs.wait_for_deployment_id == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        EXPECTED_ID='${{ inputs.expected_deployment_id }}'
        TIMEOUT='${{ inputs.annotation_timeout }}'
        ALL_JSON='${{ inputs.workloads_json }}'

        # Parse timeout to seconds (supports Ns, Nm, Nh)
        if [[ "$TIMEOUT" =~ ^([0-9]+)s$ ]]; then
          TIMEOUT_SECS="${BASH_REMATCH[1]}"
        elif [[ "$TIMEOUT" =~ ^([0-9]+)m$ ]]; then
          TIMEOUT_SECS=$((${BASH_REMATCH[1]} * 60))
        elif [[ "$TIMEOUT" =~ ^([0-9]+)h$ ]]; then
          TIMEOUT_SECS=$((${BASH_REMATCH[1]} * 3600))
        else
          TIMEOUT_SECS=300
        fi

        echo "‚è≥ Waiting for deployment-id=$EXPECTED_ID on all workloads (timeout=${TIMEOUT_SECS}s)"

        # Get annotation using jq (more reliable than jsonpath for keys with hyphens)
        get_annotation() {
          local kind="$1" name="$2" ns="$3"
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')
          local json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null)

          case "$kind" in
            Deployment|StatefulSet|DaemonSet|Rollout)
              # Pod template annotation
              echo "$json" | jq -r '.spec.template.metadata.annotations["deployment-id"] // empty'
              ;;
            *)
              # Direct metadata annotation for other resources
              echo "$json" | jq -r '.metadata.annotations["deployment-id"] // empty'
              ;;
          esac
        }

        wait_for_annotation() {
          local kind="$1" name="$2" ns="$3"
          local start_time=$(date +%s)
          local current_id=""

          while true; do
            current_id=$(get_annotation "$kind" "$name" "$ns")

            if [ "$current_id" = "$EXPECTED_ID" ]; then
              echo "  ‚úì $kind/$name has deployment-id=$EXPECTED_ID"
              return 0
            fi

            elapsed=$(($(date +%s) - start_time))
            if [ $elapsed -ge $TIMEOUT_SECS ]; then
              echo "::error::Timeout waiting for $kind/$name to have deployment-id=$EXPECTED_ID (current: ${current_id:-<not set>})"
              exit 1
            fi

            echo "  ‚è≥ $kind/$name has deployment-id=${current_id:-<not set>}, waiting... (${elapsed}s elapsed)"
            sleep 5
          done
        }

        # Process all workloads from the JSON
        echo "$ALL_JSON" | jq -r '.[] | "\(.kind)\t\(.name)\t\(.namespace // "")"' | \
        while IFS=$'\t' read -r kind name ns; do
          [ -z "$kind" ] && continue
          resolved_ns="${ns:-$NS}"
          wait_for_annotation "$kind" "$name" "$resolved_ns"
        done

        echo "‚úÖ All workloads have deployment-id=$EXPECTED_ID"
        
        # Give Kubernetes time to pick up the changes and start the rollout
        # After the deployment-id annotation appears, Kubernetes needs a moment
        # to process the update before kubectl rollout status can detect it
        echo "‚è≥ Waiting 5s for Kubernetes to process the changes..."
        sleep 5

    # Delegate exactly one Rollout to the Argo action
    - name: Wait for Argo Rollout
      if: ${{ fromJSON(steps.norm.outputs.rollouts_count) == 1 }}
      uses: skyhook-io/wait-for-rollout@v1
      with:
        rollout_name: ${{ steps.norm.outputs.first_rollout_name }}
        namespace: ${{ steps.norm.outputs.first_rollout_ns || steps.norm.outputs.namespace }}
        timeout: ${{ inputs.timeout }}
        verify_only: ${{ inputs.verify_only }}

    # Wait for standard k8s workloads
    - name: Wait for standard workloads
      if: steps.norm.outputs.non_rollouts_count != '0'
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        TIMEOUT='${{ inputs.timeout }}'
        JSON='${{ steps.norm.outputs.non_rollouts_json }}'

        # Parse timeout to seconds (supports Ns, Nm, Nh)
        if [[ "$TIMEOUT" =~ ^([0-9]+)s$ ]]; then
          TIMEOUT_SECS="${BASH_REMATCH[1]}"
        elif [[ "$TIMEOUT" =~ ^([0-9]+)m$ ]]; then
          TIMEOUT_SECS=$((${BASH_REMATCH[1]} * 60))
        elif [[ "$TIMEOUT" =~ ^([0-9]+)h$ ]]; then
          TIMEOUT_SECS=$((${BASH_REMATCH[1]} * 3600))
        else
          TIMEOUT_SECS=300
        fi

        extract() { echo "$JSON" | jq -r --arg K "$1" '.[] | select(.kind==$K) | [.name, (.namespace // "'$NS'")] | @tsv'; }

        # Wait for Kubernetes to observe the current spec generation.
        # This ensures the controller has started processing the new deployment
        # before we check rollout status.
        wait_for_generation_observed() {
          local kind="$1" name="$2" ns="$3"
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')
          local start_time=$(date +%s)

          echo "    Waiting for $kind/$name spec to be observed..."
          while true; do
            local json=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null)
            local generation=$(echo "$json" | jq -r '.metadata.generation // 0')
            local observed=$(echo "$json" | jq -r '.status.observedGeneration // 0')

            if [ "$generation" = "$observed" ] && [ "$generation" != "0" ]; then
              echo "    ‚úì Generation $generation observed"
              return 0
            fi

            local elapsed=$(($(date +%s) - start_time))
            if [ $elapsed -ge 60 ]; then
              echo "::warning::$kind/$name: generation not observed after 60s (gen=$generation, observed=$observed)"
              return 0  # Continue anyway, rollout status will give the real error
            fi

            sleep 2
          done
        }

        # Check if deployment has a stale ProgressDeadlineExceeded condition
        check_progress_deadline() {
          local kind="$1" name="$2" ns="$3"
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')

          local condition=$(kubectl get "$resource" "$name" -n "$ns" -o json 2>/dev/null | \
            jq -r '.status.conditions[]? | select(.type=="Progressing" and .status=="False" and .reason=="ProgressDeadlineExceeded") | .reason // empty')

          if [ "$condition" = "ProgressDeadlineExceeded" ]; then
            echo "    ‚ö†Ô∏è  $kind/$name has pre-existing ProgressDeadlineExceeded condition"
            echo "    ‚ö†Ô∏è  Waiting for new rollout to clear this condition..."
            return 1
          fi
          return 0
        }

        # Wait for rollout, handling pre-existing failed state
        wait_for_rollout() {
          local kind="$1" name="$2" ns="$3"
          local resource=$(echo "$kind" | tr '[:upper:]' '[:lower:]')
          local start_time=$(date +%s)

          # First, ensure Kubernetes has observed the new spec
          wait_for_generation_observed "$kind" "$name" "$ns"

          # Check for pre-existing deadline exceeded condition
          if ! check_progress_deadline "$kind" "$name" "$ns"; then
            # Wait for the condition to clear (new rollout starting)
            while ! check_progress_deadline "$kind" "$name" "$ns" >/dev/null 2>&1; do
              local elapsed=$(($(date +%s) - start_time))
              if [ $elapsed -ge $TIMEOUT_SECS ]; then
                echo "::error::$kind/$name: ProgressDeadlineExceeded condition did not clear within timeout"
                return 1
              fi
              sleep 5
            done
          fi

          # Now wait for rollout status
          kubectl rollout status "$resource/$name" -n "$ns" --timeout "$TIMEOUT"
        }

        echo "‚è≥ Waiting for standard workloads (timeout=$TIMEOUT)"

        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - Deployment/$name (ns: $ns)"
          wait_for_rollout "Deployment" "$name" "$ns"
        done < <(extract "Deployment")

        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - StatefulSet/$name (ns: $ns)"
          wait_for_rollout "StatefulSet" "$name" "$ns" || true
        done < <(extract "StatefulSet")

        while IFS=$'\t' read -r name ns; do
          [ -z "$name" ] && continue
          echo "  - DaemonSet/$name (ns: $ns)"
          wait_for_rollout "DaemonSet" "$name" "$ns" || true
        done < <(extract "DaemonSet")

        echo "‚úÖ Standard workloads are ready."

    - name: Show status
      if: inputs.show_status == 'true'
      shell: bash
      run: |
        set -euo pipefail
        NS='${{ steps.norm.outputs.namespace }}'
        ALL='${{ inputs.workloads_json }}'
        if [ -z "$ALL" ] || [ "$ALL" = "[]" ]; then
          echo "üìä No workloads provided for status."
          exit 0
        fi
        echo "üìä Final status for provided workloads:"
        echo "$ALL" | jq -r '.[] | "\(.kind)\t\(.name)\t\(.namespace // "")"' | \
        while IFS=$'\t' read -r kind name ns; do
          [ -z "$kind" ] && continue
          RES_NS="${ns:-$NS}"
          echo "‚Äî $kind/$name (ns: $RES_NS)"
          if [ "$kind" = "Rollout" ]; then
            # Only a summary; full details come from the delegated action
            kubectl argo rollouts get rollout "$name" -n "$RES_NS" --no-color || true
          else
            kubectl get "$kind" "$name" -n "$RES_NS" -o wide || true
          fi
        done